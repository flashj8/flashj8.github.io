<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVD Movie Recommender System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d1117;
            color: #e6edf3;
            min-height: 100vh;
            padding: 20px;
        }

        h1 {
            text-align: center;
            font-size: 2em;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            text-align: center;
            color: #8b949e;
            margin-bottom: 30px;
            font-size: 0.95em;
        }

        .container {
            max-width: 1300px;
            margin: 0 auto;
        }

        .section {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
        }

        .section h2 {
            font-size: 1.3em;
            margin-bottom: 6px;
            color: #58a6ff;
        }

        .section .desc {
            color: #8b949e;
            font-size: 0.85em;
            margin-bottom: 16px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        thead th {
            background: #21262d;
            padding: 10px 8px;
            text-align: center;
            border-bottom: 2px solid #30363d;
            position: sticky;
            top: 0;
            font-weight: 600;
            color: #c9d1d9;
        }

        thead th:first-child {
            text-align: left;
            min-width: 140px;
        }

        tbody td {
            padding: 8px;
            text-align: center;
            border-bottom: 1px solid #21262d;
        }

        tbody td:first-child {
            text-align: left;
            font-weight: 500;
            color: #e6edf3;
        }

        tbody tr:hover {
            background: #1c2129;
        }

        .rating-cell {
            position: relative;
        }

        .rating-cell input {
            width: 52px;
            padding: 5px 4px;
            text-align: center;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #e6edf3;
            font-size: 0.9em;
            transition: border-color 0.2s;
        }

        .rating-cell input:focus {
            outline: none;
            border-color: #58a6ff;
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.2);
        }

        .rating-cell input:hover {
            border-color: #484f58;
        }

        .empty-rating input {
            color: #484f58;
            font-style: italic;
        }

        .pred-cell {
            font-weight: 600;
            border-radius: 4px;
            padding: 4px 6px;
        }

        .movie-emoji {
            margin-right: 4px;
        }

        .user-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .user-icon {
            font-size: 1.2em;
        }

        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 8px 18px;
            border: 1px solid #30363d;
            border-radius: 8px;
            background: #21262d;
            color: #c9d1d9;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        button:hover {
            background: #30363d;
            border-color: #484f58;
        }

        button.primary {
            background: #238636;
            border-color: #2ea043;
            color: #fff;
        }

        button.primary:hover {
            background: #2ea043;
        }

        .k-control {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #8b949e;
            font-size: 0.85em;
        }

        .k-control input[type="range"] {
            width: 100px;
            accent-color: #58a6ff;
        }

        .k-control span {
            color: #58a6ff;
            font-weight: 600;
            min-width: 20px;
        }

        /* Visualization */
        .viz-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }

        @media (max-width: 900px) {
            .viz-container {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 10px;
            padding: 20px;
        }

        .viz-panel h3 {
            font-size: 1em;
            color: #c9d1d9;
            margin-bottom: 12px;
        }

        canvas {
            width: 100%;
            height: auto;
            border-radius: 6px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 10px;
            font-size: 0.78em;
            color: #8b949e;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .svd-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 12px;
        }

        .svd-matrix {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .svd-matrix h4 {
            font-size: 0.85em;
            color: #58a6ff;
            margin-bottom: 8px;
        }

        .mini-grid {
            display: inline-grid;
            gap: 2px;
            font-size: 0.7em;
            font-family: 'Courier New', monospace;
        }

        .mini-cell {
            padding: 3px 5px;
            border-radius: 3px;
            min-width: 38px;
            text-align: center;
        }

        .tooltip {
            position: fixed;
            background: #21262d;
            border: 1px solid #484f58;
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 0.82em;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            max-width: 220px;
            display: none;
        }

        .top-recs {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .rec-bar-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rec-bar-label {
            min-width: 110px;
            font-size: 0.82em;
            text-align: right;
            color: #c9d1d9;
        }

        .rec-bar-track {
            flex: 1;
            height: 20px;
            background: #21262d;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .rec-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 6px;
            font-size: 0.75em;
            font-weight: 600;
            color: #fff;
            min-width: 32px;
        }

        .user-tab-bar {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }

        .user-tab {
            padding: 5px 14px;
            border-radius: 6px;
            font-size: 0.82em;
            cursor: pointer;
            background: #21262d;
            border: 1px solid #30363d;
            color: #8b949e;
            transition: all 0.2s;
        }

        .user-tab.active {
            background: #58a6ff;
            color: #0d1117;
            border-color: #58a6ff;
            font-weight: 600;
        }

        .heatmap-label {
            font-size: 0.7em;
            fill: #8b949e;
        }

        .info-badge {
            display: inline-block;
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 4px 10px;
            font-size: 0.78em;
            color: #8b949e;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ SVD Movie Recommender System</h1>
        <p class="subtitle">Singular Value Decomposition for collaborative filtering ‚Äî edit ratings, see predictions update live</p>

        <!-- Section 1: Ratings Table -->
        <div class="section">
            <h2>üìä User-Movie Ratings Matrix</h2>
            <p class="desc">Click any cell to edit a rating (1‚Äì5). Leave blank or set to 0 for unknown ratings. The SVD will predict missing values.</p>
            <div class="controls">
                <button class="primary" onclick="computeSVD()">‚ñ∂ Run SVD</button>
                <button onclick="resetRatings()">‚Ü∫ Reset to Defaults</button>
                <button onclick="randomizeRatings()">üé≤ Randomize</button>
                <div class="k-control">
                    <label>Latent factors (k):</label>
                    <input type="range" id="kSlider" min="1" max="5" value="2" oninput="updateK(this.value)">
                    <span id="kValue">2</span>
                </div>
                <span class="info-badge" id="rmseDisplay">RMSE: ‚Äî</span>
            </div>
            <div style="overflow-x:auto;">
                <table id="ratingsTable"></table>
            </div>
        </div>

        <!-- Section 2: Predictions Table -->
        <div class="section">
            <h2>üéØ Predicted Ratings & Recommendations</h2>
            <p class="desc">Cells highlighted in <span style="color:#f0883e;">orange</span> are SVD-predicted values for previously unrated movies. Brighter = higher predicted rating.</p>
            <div style="overflow-x:auto;">
                <table id="predictionsTable"></table>
            </div>
        </div>

        <!-- Section 3: Visualizations -->
        <div class="section">
            <h2>üîç SVD Decomposition Visualizations</h2>
            <p class="desc">Explore how users and movies map into latent feature space and how singular values capture variance.</p>

            <div class="viz-container">
                <!-- Latent Space Scatter -->
                <div class="viz-panel">
                    <h3>üó∫Ô∏è Latent Space (Users & Movies)</h3>
                    <canvas id="scatterCanvas" width="500" height="400"></canvas>
                    <div class="legend" id="scatterLegend"></div>
                </div>

                <!-- Top Recommendations Bar Chart -->
                <div class="viz-panel">
                    <h3>üèÜ Top Recommendations Per User</h3>
                    <div class="user-tab-bar" id="userTabs"></div>
                    <div class="top-recs" id="recBars"></div>
                </div>

                <!-- Singular Values -->
                <div class="viz-panel">
                    <h3>üìà Singular Values (Energy)</h3>
                    <canvas id="sigmaCanvas" width="500" height="250"></canvas>
                    <p style="font-size:0.75em;color:#8b949e;margin-top:8px;">Each singular value represents the importance of a latent factor. Keeping top-k values compresses the matrix while preserving the most signal.</p>
                </div>

                <!-- Heatmap -->
                <div class="viz-panel">
                    <h3>üå°Ô∏è Prediction Heatmap</h3>
                    <canvas id="heatmapCanvas" width="500" height="350"></canvas>
                </div>
            </div>

            <!-- SVD Matrices -->
            <h3 style="margin-top:20px;margin-bottom:10px;color:#c9d1d9;font-size:1em;">üìê Decomposed Matrices (A ‚âà U ¬∑ Œ£ ¬∑ V·µÄ)</h3>
            <div class="svd-info" id="svdMatrices"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
    // ==================== DATA ====================
    const MOVIES = [
        { name: "The Matrix", emoji: "ü§ñ" },
        { name: "Titanic", emoji: "üö¢" },
        { name: "Toy Story", emoji: "üß∏" },
        { name: "The Godfather", emoji: "üé©" },
        { name: "Inception", emoji: "üí≠" },
        { name: "Frozen", emoji: "‚ùÑÔ∏è" },
        { name: "Pulp Fiction", emoji: "üíº" },
        { name: "Avengers", emoji: "ü¶∏" }
    ];

    const USERS = ["Maddox", "Aaron", "Finley", "Sasha", "Eshna"];
    const USER_ICONS = ["üë©‚Äçüíª", "üë®‚Äçüé®", "üë©‚Äçüî¨", "üë®‚ÄçüöÄ", "üë©‚Äçüé§"];
    const USER_COLORS = ["#ff6b6b", "#ffd93d", "#6bcb77", "#4d96ff", "#cc5de8"];
    const MOVIE_COLORS = ["#ff922b", "#20c997", "#845ef7", "#f06595", "#339af0", "#5c7cfa", "#e64980", "#51cf66"];

    // Default ratings matrix (0 = unrated)
    const DEFAULT_RATINGS = [
    // Maddox (loves action/complex, dislikes romance-heavy)
        [5, 1, 0, 0, 5, 0, 2, 5],

    // Aaron (meaningful, uplifting, teamwork)
        [0, 4, 5, 0, 0, 4, 2, 4],

    // Finely (kids + classics)
        [2, 4, 5, 5, 0, 5, 0, 0],

    // Sasha (romance + kids)
        [0, 5, 5, 2, 0, 5, 0, 3],

    // Eshna (emotional drama + kids)
        [0, 5, 4, 4, 0, 4, 3, 0]
];

    let ratings = DEFAULT_RATINGS.map(r => [...r]);
    let predictions = null;
    let U = null, S = null, Vt = null;
    let kValue = 2;
    let selectedUser = 0;

    // ==================== LINEAR ALGEBRA ====================

    function transpose(M) {
        const rows = M.length, cols = M[0].length;
        const T = [];
        for (let j = 0; j < cols; j++) {
            T[j] = [];
            for (let i = 0; i < rows; i++) {
                T[j][i] = M[i][j];
            }
        }
        return T;
    }

    function matMul(A, B) {
        const m = A.length, n = B[0].length, p = B.length;
        const C = [];
        for (let i = 0; i < m; i++) {
            C[i] = [];
            for (let j = 0; j < n; j++) {
                let s = 0;
                for (let k = 0; k < p; k++) s += A[i][k] * B[k][j];
                C[i][j] = s;
            }
        }
        return C;
    }

    function norm(v) {
        let s = 0;
        for (let i = 0; i < v.length; i++) s += v[i] * v[i];
        return Math.sqrt(s);
    }

    function dot(a, b) {
        let s = 0;
        for (let i = 0; i < a.length; i++) s += a[i] * b[i];
        return s;
    }

    // Power iteration SVD ‚Äî good enough for small matrices
    function svd(matrix, maxK) {
        const m = matrix.length, n = matrix[0].length;
        const k = Math.min(maxK, m, n);

        // Work on a copy
        let A = matrix.map(r => [...r]);

        const Us = [];
        const sigmas = [];
        const Vs = [];

        for (let f = 0; f < k; f++) {
            // Power iteration on A^T A to find top singular vector
            let v = [];
            for (let j = 0; j < n; j++) v[j] = Math.random() - 0.5;
            let vn = norm(v);
            for (let j = 0; j < n; j++) v[j] /= vn;

            for (let iter = 0; iter < 200; iter++) {
                // u = A * v
                let u = [];
                for (let i = 0; i < m; i++) {
                    u[i] = 0;
                    for (let j = 0; j < n; j++) u[i] += A[i][j] * v[j];
                }
                let un = norm(u);
                if (un < 1e-10) break;
                for (let i = 0; i < m; i++) u[i] /= un;

                // v = A^T * u
                let vNew = [];
                for (let j = 0; j < n; j++) {
                    vNew[j] = 0;
                    for (let i = 0; i < m; i++) vNew[j] += A[i][j] * u[i];
                }
                let vnNew = norm(vNew);
                if (vnNew < 1e-10) break;
                for (let j = 0; j < n; j++) vNew[j] /= vnNew;

                v = vNew;
            }

            // Compute sigma
            let Av = [];
            for (let i = 0; i < m; i++) {
                Av[i] = 0;
                for (let j = 0; j < n; j++) Av[i] += A[i][j] * v[j];
            }
            let sigma = norm(Av);
            let u = [];
            if (sigma > 1e-10) {
                for (let i = 0; i < m; i++) u[i] = Av[i] / sigma;
            } else {
                for (let i = 0; i < m; i++) u[i] = 0;
            }

            Us.push(u);
            sigmas.push(sigma);
            Vs.push(v);

            // Deflate: A = A - sigma * u * v^T
            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    A[i][j] -= sigma * u[i] * v[j];
                }
            }
        }

        // Format into matrices
        const Umat = [];
        for (let i = 0; i < m; i++) {
            Umat[i] = [];
            for (let f = 0; f < k; f++) {
                Umat[i][f] = Us[f][i];
            }
        }

        const Vtmat = [];
        for (let f = 0; f < k; f++) {
            Vtmat[f] = Vs[f];
        }

        return { U: Umat, S: sigmas, Vt: Vtmat };
    }

    function computeSVD() {
        const m = USERS.length, n = MOVIES.length;

        // Fill missing ratings with row mean for SVD computation
        const filled = [];
        const mask = []; // 1 if originally rated, 0 if not
        for (let i = 0; i < m; i++) {
            filled[i] = [];
            mask[i] = [];
            let sum = 0, count = 0;
            for (let j = 0; j < n; j++) {
                if (ratings[i][j] > 0) {
                    sum += ratings[i][j];
                    count++;
                }
                mask[i][j] = ratings[i][j] > 0 ? 1 : 0;
            }
            const mean = count > 0 ? sum / count : 2.5;
            for (let j = 0; j < n; j++) {
                filled[i][j] = ratings[i][j] > 0 ? ratings[i][j] : mean;
            }
        }

        const k = Math.min(kValue, m, n);
        const result = svd(filled, k);
        U = result.U;
        S = result.S;
        Vt = result.Vt;

        // Reconstruct: U * diag(S) * Vt
        const SigmaVt = [];
        for (let f = 0; f < k; f++) {
            SigmaVt[f] = [];
            for (let j = 0; j < n; j++) {
                SigmaVt[f][j] = S[f] * Vt[f][j];
            }
        }

        predictions = matMul(U, SigmaVt);

        // Clamp predictions to [0.5, 5.5]
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                predictions[i][j] = Math.max(0.5, Math.min(5.5, predictions[i][j]));
            }
        }

        // Compute RMSE on known ratings
        let sse = 0, cnt = 0;
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                if (mask[i][j]) {
                    const err = predictions[i][j] - ratings[i][j];
                    sse += err * err;
                    cnt++;
                }
            }
        }
        const rmse = cnt > 0 ? Math.sqrt(sse / cnt) : 0;
        document.getElementById('rmseDisplay').textContent = `RMSE: ${rmse.toFixed(3)}`;

        renderPredictions(mask);
        renderScatter();
        renderSigmaChart();
        renderHeatmap();
        renderRecBars();
        renderSVDMatrices();
    }

    // ==================== RENDER TABLES ====================

    function renderRatingsTable() {
        const table = document.getElementById('ratingsTable');
        let html = '<thead><tr><th>Movie</th>';
        for (let i = 0; i < USERS.length; i++) {
            html += `<th><div class="user-header"><span class="user-icon">${USER_ICONS[i]}</span>${USERS[i]}</div></th>`;
        }
        html += '</tr></thead><tbody>';

        for (let j = 0; j < MOVIES.length; j++) {
            html += `<tr><td><span class="movie-emoji">${MOVIES[j].emoji}</span>${MOVIES[j].name}</td>`;
            for (let i = 0; i < USERS.length; i++) {
                const val = ratings[i][j];
                const cls = val === 0 ? 'rating-cell empty-rating' : 'rating-cell';
                html += `<td class="${cls}"><input type="number" min="0" max="5" step="1" value="${val}" onchange="updateRating(${i},${j},this.value)" onkeyup="if(event.key==='Enter')computeSVD()"></td>`;
            }
            html += '</tr>';
        }
        html += '</tbody>';
        table.innerHTML = html;
    }

    function updateRating(user, movie, val) {
        let v = parseInt(val) || 0;
        if (v < 0) v = 0;
        if (v > 5) v = 5;
        ratings[user][movie] = v;
        renderRatingsTable();
        computeSVD();
    }

    function renderPredictions(mask) {
        const table = document.getElementById('predictionsTable');
        let html = '<thead><tr><th>Movie</th>';
        for (let i = 0; i < USERS.length; i++) {
            html += `<th><div class="user-header"><span class="user-icon">${USER_ICONS[i]}</span>${USERS[i]}</div></th>`;
        }
        html += '</tr></thead><tbody>';

        for (let j = 0; j < MOVIES.length; j++) {
            html += `<tr><td><span class="movie-emoji">${MOVIES[j].emoji}</span>${MOVIES[j].name}</td>`;
            for (let i = 0; i < USERS.length; i++) {
                const pred = predictions[i][j];
                const isNew = !mask[i][j];
                const stars = ratingToStars(pred);
                let bg = 'transparent';
                let color = '#c9d1d9';
                if (isNew) {
                    const intensity = Math.min(1, (pred - 0.5) / 5);
                    const r = Math.round(240 * intensity + 30);
                    const g = Math.round(136 * intensity + 30);
                    const b = Math.round(62 * intensity + 20);
                    bg = `rgba(${r}, ${g}, ${b}, 0.35)`;
                    color = '#f0883e';
                }
                html += `<td class="pred-cell" style="background:${bg};color:${color}" title="${isNew ? 'Predicted' : 'Known'}: ${pred.toFixed(2)}">${pred.toFixed(1)} ${stars}</td>`;
            }
            html += '</tr>';
        }
        html += '</tbody>';
        table.innerHTML = html;
    }

    function ratingToStars(r) {
        const full = Math.round(r);
        let s = '';
        for (let i = 0; i < 5; i++) s += i < full ? '‚òÖ' : '‚òÜ';
        return `<span style="font-size:0.75em;opacity:0.6;">${s}</span>`;
    }

    // ==================== VISUALIZATIONS ====================

    function renderScatter() {
        const canvas = document.getElementById('scatterCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        if (!U || !Vt || U[0].length < 2) {
            ctx.fillStyle = '#8b949e';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Need k ‚â• 2 for 2D scatter plot', W/2, H/2);
            return;
        }

        // Collect all points
        const allX = [], allY = [];
        for (let i = 0; i < USERS.length; i++) {
            allX.push(U[i][0] * S[0]);
            allY.push(U[i][1] * S[1]);
        }
        for (let j = 0; j < MOVIES.length; j++) {
            allX.push(Vt[0][j] * S[0]);
            allY.push(Vt[1][j] * S[1]);
        }

        const margin = 60;
        const xMin = Math.min(...allX), xMax = Math.max(...allX);
        const yMin = Math.min(...allY), yMax = Math.max(...allY);
        const xRange = (xMax - xMin) || 1;
        const yRange = (yMax - yMin) || 1;
        const pad = 0.15;

        const mapX = x => margin + ((x - xMin + xRange * pad) / (xRange * (1 + 2 * pad))) * (W - 2 * margin);
        const mapY = y => H - margin - ((y - yMin + yRange * pad) / (yRange * (1 + 2 * pad))) * (H - 2 * margin);

        // Grid
        ctx.strokeStyle = '#21262d';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
            const x = margin + i * (W - 2 * margin) / 4;
            ctx.beginPath(); ctx.moveTo(x, margin); ctx.lineTo(x, H - margin); ctx.stroke();
            const y = margin + i * (H - 2 * margin) / 4;
            ctx.beginPath(); ctx.moveTo(margin, y); ctx.lineTo(W - margin, y); ctx.stroke();
        }

        // Axes labels
        ctx.fillStyle = '#484f58';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Factor 1', W / 2, H - 10);
        ctx.save();
        ctx.translate(15, H / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Factor 2', 0, 0);
        ctx.restore();

        // Draw movies as squares
        for (let j = 0; j < MOVIES.length; j++) {
            const px = mapX(Vt[0][j] * S[0]);
            const py = mapY(Vt[1][j] * S[1]);
            ctx.fillStyle = MOVIE_COLORS[j % MOVIE_COLORS.length];
            ctx.globalAlpha = 0.8;
            ctx.fillRect(px - 7, py - 7, 14, 14);
            ctx.globalAlpha = 1;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(px - 7, py - 7, 14, 14);
            ctx.fillStyle = '#e6edf3';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(MOVIES[j].emoji, px, py - 12);
        }

        // Draw users as circles
        for (let i = 0; i < USERS.length; i++) {
            const px = mapX(U[i][0] * S[0]);
            const py = mapY(U[i][1] * S[1]);

            // Glow
            const grad = ctx.createRadialGradient(px, py, 0, px, py, 20);
            grad.addColorStop(0, USER_COLORS[i] + '66');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(px, py, 20, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = USER_COLORS[i];
            ctx.beginPath();
            ctx.arc(px, py, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#e6edf3';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(USERS[i], px, py - 15);
        }

        // Legend
        const legendEl = document.getElementById('scatterLegend');
        let legHtml = '';
        for (let i = 0; i < USERS.length; i++) {
            legHtml += `<div class="legend-item"><span class="legend-dot" style="background:${USER_COLORS[i]};border-radius:50%;"></span>${USER_ICONS[i]} ${USERS[i]}</div>`;
        }
        for (let j = 0; j < MOVIES.length; j++) {
            legHtml += `<div class="legend-item"><span class="legend-dot" style="background:${MOVIE_COLORS[j % MOVIE_COLORS.length]};border-radius:2px;"></span>${MOVIES[j].emoji} ${MOVIES[j].name}</div>`;
        }
        legendEl.innerHTML = legHtml;
    }

    function renderSigmaChart() {
        const canvas = document.getElementById('sigmaCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        if (!S || S.length === 0) return;

        const margin = { top: 30, right: 30, bottom: 40, left: 50 };
        const plotW = W - margin.left - margin.right;
        const plotH = H - margin.top - margin.bottom;

        const maxS = Math.max(...S);
        const total = S.reduce((a, b) => a + b * b, 0);

        // Bars
        const barW = Math.min(60, plotW / S.length * 0.6);
        const gap = (plotW - barW * S.length) / (S.length + 1);

        // Axis
        ctx.strokeStyle = '#30363d';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(margin.left, margin.top);
        ctx.lineTo(margin.left, H - margin.bottom);
        ctx.lineTo(W - margin.right, H - margin.bottom);
        ctx.stroke();

        for (let i = 0; i < S.length; i++) {
            const x = margin.left + gap + i * (barW + gap);
            const barH = (S[i] / (maxS * 1.1)) * plotH;
            const y = H - margin.bottom - barH;
            const pct = (S[i] * S[i] / total * 100);

            // Gradient bar
            const grad = ctx.createLinearGradient(x, y, x, H - margin.bottom);
            const hue = 200 + i * 40;
            grad.addColorStop(0, `hsl(${hue}, 80%, 65%)`);
            grad.addColorStop(1, `hsl(${hue}, 80%, 35%)`);
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.roundRect(x, y, barW, barH, [4, 4, 0, 0]);
            ctx.fill();

            // Value label
            ctx.fillStyle = '#e6edf3';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(S[i].toFixed(2), x + barW / 2, y - 14);

            // Percentage
            ctx.fillStyle = '#8b949e';
            ctx.font = '10px sans-serif';
            ctx.fillText(`${pct.toFixed(1)}%`, x + barW / 2, y - 3);

            // X label
            ctx.fillStyle = '#8b949e';
            ctx.font = '11px sans-serif';
            ctx.fillText(`œÉ${i + 1}`, x + barW / 2, H - margin.bottom + 18);
        }

        // Y axis label
        ctx.fillStyle = '#484f58';
        ctx.font = '11px sans-serif';
        ctx.save();
        ctx.translate(15, margin.top + plotH / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Singular Value', 0, 0);
        ctx.restore();

        // Title
        ctx.fillStyle = '#8b949e';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`Total energy captured: ${(S.slice(0, kValue).reduce((a, b) => a + b * b, 0) / total * 100).toFixed(1)}%`, W / 2, H - 5);
    }

    function renderHeatmap() {
        const canvas = document.getElementById('heatmapCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        if (!predictions) return;

        const margin = { top: 15, right: 20, bottom: 60, left: 80 };
        const plotW = W - margin.left - margin.right;
        const plotH = H - margin.top - margin.bottom;

        const cellW = plotW / MOVIES.length;
        const cellH = plotH / USERS.length;

        for (let i = 0; i < USERS.length; i++) {
            for (let j = 0; j < MOVIES.length; j++) {
                const val = predictions[i][j];
                const t = Math.max(0, Math.min(1, (val - 0.5) / 5));

                // Color interpolation: blue (low) -> yellow (mid) -> red (high)
                let r, g, b;
                if (t < 0.5) {
                    const s = t * 2;
                    r = Math.round(30 + s * 225);
                    g = Math.round(60 + s * 180);
                    b = Math.round(180 - s * 130);
                } else {
                    const s = (t - 0.5) * 2;
                    r = Math.round(255 - s * 20);
                    g = Math.round(240 - s * 180);
                    b = Math.round(50 - s * 30);
                }

                const x = margin.left + j * cellW;
                const y = margin.top + i * cellH;

                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);

                // Text
                ctx.fillStyle = t > 0.4 && t < 0.7 ? '#000' : '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(val.toFixed(1), x + cellW / 2, y + cellH / 2);

                // Unrated indicator
                if (ratings[i][j] === 0) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3, 2]);
                    ctx.strokeRect(x + 2, y + 2, cellW - 4, cellH - 4);
                    ctx.setLineDash([]);
                }
            }
        }

        // Labels
        ctx.fillStyle = '#c9d1d9';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 0; i < USERS.length; i++) {
            ctx.fillText(`${USER_ICONS[i]} ${USERS[i]}`, margin.left - 8, margin.top + i * cellH + cellH / 2);
        }

        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (let j = 0; j < MOVIES.length; j++) {
            ctx.save();
            ctx.translate(margin.left + j * cellW + cellW / 2, H - margin.bottom + 8);
            ctx.rotate(-Math.PI / 4);
            ctx.fillText(`${MOVIES[j].emoji} ${MOVIES[j].name}`, 0, 0);
            ctx.restore();
        }

        // Legend bar
        const legX = W - 16;
        const legH = plotH;
        const legW = 10;
        for (let py = 0; py < legH; py++) {
            const t = 1 - py / legH;
            let r2, g2, b2;
            if (t < 0.5) {
                const s = t * 2;
                r2 = Math.round(30 + s * 225);
                g2 = Math.round(60 + s * 180);
                b2 = Math.round(180 - s * 130);
            } else {
                const s = (t - 0.5) * 2;
                r2 = Math.round(255 - s * 20);
                g2 = Math.round(240 - s * 180);
                b2 = Math.round(50 - s * 30);
            }
            ctx.fillStyle = `rgb(${r2},${g2},${b2})`;
            ctx.fillRect(legX - legW, margin.top + py, legW, 1);
        }
        ctx.fillStyle = '#8b949e';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('5', legX - legW / 2, margin.top - 8);
        ctx.fillText('1', legX - legW / 2, margin.top + legH + 8);
    }

    function renderRecBars() {
        // User tabs
        const tabBar = document.getElementById('userTabs');
        let tabHtml = '';
        for (let i = 0; i < USERS.length; i++) {
            tabHtml += `<div class="user-tab ${i === selectedUser ? 'active' : ''}" onclick="selectUser(${i})">${USER_ICONS[i]} ${USERS[i]}</div>`;
        }
        tabBar.innerHTML = tabHtml;

        if (!predictions) {
            document.getElementById('recBars').innerHTML = '<p style="color:#8b949e;font-size:0.85em;">Click "Run SVD" to see recommendations</p>';
            return;
        }

        const i = selectedUser;
        // Sort movies by predicted rating (show unrated movies first, then all)
        const movieScores = MOVIES.map((m, j) => ({
            name: m.name,
            emoji: m.emoji,
            pred: predictions[i][j],
            known: ratings[i][j] > 0,
            idx: j
        }));
        movieScores.sort((a, b) => b.pred - a.pred);

        let html = '';
        const barColors = ['#ff6b6b', '#ffd93d', '#6bcb77', '#4d96ff', '#cc5de8', '#f06595', '#339af0', '#20c997'];
        for (let m = 0; m < movieScores.length; m++) {
            const mv = movieScores[m];
            const width = (mv.pred / 5.5) * 100;
            const color = barColors[mv.idx % barColors.length];
            const opacity = mv.known ? '0.5' : '1';
            const tag = mv.known ? '' : ' üÜï';
            html += `<div class="rec-bar-row">
                <div class="rec-bar-label" style="opacity:${opacity}">${mv.emoji} ${mv.name}${tag}</div>
                <div class="rec-bar-track">
                    <div class="rec-bar-fill" style="width:${width}%;background:${color};opacity:${opacity}">${mv.pred.toFixed(1)}</div>
                </div>
            </div>`;
        }
        document.getElementById('recBars').innerHTML = html;
    }

    function selectUser(i) {
        selectedUser = i;
        renderRecBars();
    }

    function renderSVDMatrices() {
        const el = document.getElementById('svdMatrices');
        if (!U || !S || !Vt) {
            el.innerHTML = '<p style="color:#8b949e;grid-column:1/-1;font-size:0.85em;">Run SVD to see decomposed matrices</p>';
            return;
        }

        const k = S.length;

        // U matrix
        let uHtml = `<div class="svd-matrix"><h4>U (${USERS.length}√ó${k})</h4><div class="mini-grid" style="grid-template-columns:repeat(${k}, 1fr);">`;
        for (let i = 0; i < USERS.length; i++) {
            for (let f = 0; f < k; f++) {
                const v = U[i][f];
                const color = valColor(v);
                uHtml += `<div class="mini-cell" style="background:${color}">${v.toFixed(2)}</div>`;
            }
        }
        uHtml += `</div><p style="font-size:0.7em;color:#8b949e;margin-top:6px;">Rows = Users</p></div>`;

        // Sigma
        let sHtml = `<div class="svd-matrix"><h4>Œ£ (${k}√ó${k})</h4><div class="mini-grid" style="grid-template-columns:repeat(${k}, 1fr);">`;
        for (let i = 0; i < k; i++) {
            for (let j = 0; j < k; j++) {
                const v = i === j ? S[i] : 0;
                const color = i === j ? valColor(v / Math.max(...S) * 0.8) : 'transparent';
                sHtml += `<div class="mini-cell" style="background:${color}">${v.toFixed(1)}</div>`;
            }
        }
        sHtml += `</div><p style="font-size:0.7em;color:#8b949e;margin-top:6px;">Diagonal = Singular Values</p></div>`;

        // Vt matrix
        let vtHtml = `<div class="svd-matrix"><h4>V·µÄ (${k}√ó${MOVIES.length})</h4><div class="mini-grid" style="grid-template-columns:repeat(${MOVIES.length}, 1fr);">`;
        for (let f = 0; f < k; f++) {
            for (let j = 0; j < MOVIES.length; j++) {
                const v = Vt[f][j];
                const color = valColor(v);
                vtHtml += `<div class="mini-cell" style="background:${color}">${v.toFixed(2)}</div>`;
            }
        }
        vtHtml += `</div><p style="font-size:0.7em;color:#8b949e;margin-top:6px;">Cols = Movies</p></div>`;

        el.innerHTML = uHtml + sHtml + vtHtml;
    }

    function valColor(v) {
        if (v > 0) {
            const t = Math.min(1, Math.abs(v));
            return `rgba(88, 166, 255, ${0.15 + t * 0.55})`;
        } else {
            const t = Math.min(1, Math.abs(v));
            return `rgba(255, 107, 107, ${0.15 + t * 0.55})`;
        }
    }

    // ==================== CONTROLS ====================

    function updateK(val) {
        kValue = parseInt(val);
        document.getElementById('kValue').textContent = kValue;
        computeSVD();
    }

    function resetRatings() {
        ratings = DEFAULT_RATINGS.map(r => [...r]);
        renderRatingsTable();
        computeSVD();
    }

    function randomizeRatings() {
        for (let i = 0; i < USERS.length; i++) {
            for (let j = 0; j < MOVIES.length; j++) {
                if (Math.random() < 0.35) {
                    ratings[i][j] = 0; // unrated
                } else {
                    ratings[i][j] = Math.floor(Math.random() * 5) + 1;
                }
            }
        }
        renderRatingsTable();
        computeSVD();
    }

    // ==================== INIT ====================
    renderRatingsTable();
    computeSVD();
    </script>
</body>
</html>